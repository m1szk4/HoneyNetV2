# UPnP Honeypot Logstash Pipeline
# Processes UPnP Router/IoT Gateway honeypot logs (SSDP + SOAP)

input {
  file {
    path => "/input/upnp/upnp.json"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/upnp_sincedb"
    codec => json
    type => "upnp"
  }
}

filter {
  # Parse UPnP JSON logs
  if [type] == "upnp" {
    # Extract timestamp
    date {
      match => ["timestamp", "ISO8601"]
      target => "@timestamp"
    }

    # GeoIP lookup BEFORE anonymization
    if [src_ip] {
      geoip {
        source => "src_ip"
        target => "geoip"
        fields => ["country_code2"]
        tag_on_failure => ["_geoip_lookup_failure"]
      }

      # Extract country code
      if [geoip][country_code2] {
        mutate {
          add_field => { "source_ip_country" => "%{[geoip][country_code2]}" }
        }
      } else {
        mutate {
          add_field => { "source_ip_country" => "" }
        }
      }
    }

    # Anonymize source IP AFTER GeoIP
    ruby {
      code => '
        require "digest"
        salt = ENV["ANON_SALT"] || "default_salt"
        if event.get("src_ip")
          hashed_ip = Digest::SHA256.hexdigest(salt + event.get("src_ip").to_s)
          event.set("source_ip_hash", hashed_ip[0..15])
        end
      '
    }

    # Generate unique event ID
    if ![session_id] {
      uuid {
        target => "event_id"
      }
    } else {
      mutate {
        add_field => { "event_id" => "%{session_id}" }
      }
    }

    # Normalize fields for ClickHouse schema
    # UPnP honeypot provides event_types:
    # - ssdp_msearch, ssdp_response_sent (SSDP discovery)
    # - http_get, device_description_served (device description)
    # - soap_request (SOAP control actions)
    # - attack_detected (AddPortMapping/DeletePortMapping abuse)

    # Add honeypot type (if not already present)
    if ![honeypot_type] {
      mutate {
        add_field => { "honeypot_type" => "upnp" }
      }
    }

    # Rename fields to match ClickHouse schema
    mutate {
      rename => {
        "src_port" => "source_port"
        "dest_ip" => "destination_ip"
        "dest_port" => "destination_port"
      }
    }

    # Handle attack-specific fields
    if [attack_detected] == true {
      # Extract attack information
      if [params] {
        # Convert params object to JSON string for storage
        ruby {
          code => '
            require "json"
            if event.get("params")
              event.set("attack_details", event.get("params").to_json)
            end
          '
        }
      }

      # Add attack type to event_type for easier querying
      if [attack_type] {
        mutate {
          add_field => { "original_event_type" => "%{event_type}" }
          replace => { "event_type" => "attack_detected" }
        }
      }
    }

    # Extract UPnP-specific fields
    if [search_target] {
      mutate {
        add_field => { "upnp_search_target" => "%{search_target}" }
      }
    }

    if [soap_action] {
      mutate {
        add_field => { "upnp_soap_action" => "%{soap_action}" }
      }
    }

    if [action] {
      mutate {
        add_field => { "upnp_action" => "%{action}" }
      }
    }

    if [path] {
      mutate {
        add_field => { "upnp_path" => "%{path}" }
      }
    }

    # Handle SOAP parameters for port mapping
    if [params] {
      if [params][NewExternalPort] {
        mutate {
          add_field => { "upnp_external_port" => "%{[params][NewExternalPort]}" }
        }
      }
      if [params][NewInternalPort] {
        mutate {
          add_field => { "upnp_internal_port" => "%{[params][NewInternalPort]}" }
        }
      }
      if [params][NewInternalClient] {
        mutate {
          add_field => { "upnp_internal_client" => "%{[params][NewInternalClient]}" }
        }
      }
      if [params][NewProtocol] {
        mutate {
          add_field => { "upnp_protocol" => "%{[params][NewProtocol]}" }
        }
      }
    }

    # Remove original IP and temporary fields
    mutate {
      remove_field => ["src_ip", "geoip", "host", "type"]
    }
  }
}

output {
  if [type] == "upnp" or [honeypot_type] == "upnp" {
    # Output to ClickHouse honeypot_events table
    http {
      url => "http://${CLICKHOUSE_HOST:clickhouse}:${CLICKHOUSE_PORT:8123}/"
      http_method => "post"
      format => "message"
      content_type => "text/plain"
      message => 'INSERT INTO %{CLICKHOUSE_DB:honeynet}.honeypot_events FORMAT JSONEachRow
{
  "timestamp": "%{@timestamp}",
  "event_id": "%{event_id}",
  "honeypot_type": "upnp",
  "source_ip_hash": "%{source_ip_hash}",
  "source_ip_country": "%{source_ip_country}",
  "source_port": %{source_port:0},
  "dest_ip": "%{destination_ip}",
  "dest_port": %{destination_port:1900},
  "protocol": "%{protocol}",
  "event_type": "%{event_type}",
  "username": "",
  "password": "",
  "command": "%{[upnp_action]}",
  "session_id": "%{event_id}",
  "success": false,
  "raw_data": "%{[upnp_soap_action]}"
}'
      user => "${CLICKHOUSE_USER:honeynet}"
      password => "${CLICKHOUSE_PASSWORD:changeme}"
    }

    # Special handling for attack events
    if [attack_detected] == true {
      http {
        url => "http://${CLICKHOUSE_HOST:clickhouse}:${CLICKHOUSE_PORT:8123}/"
        http_method => "post"
        format => "message"
        content_type => "text/plain"
        message => 'INSERT INTO %{CLICKHOUSE_DB:honeynet}.upnp_attacks FORMAT JSONEachRow
{
  "timestamp": "%{@timestamp}",
  "attack_id": "%{event_id}",
  "source_ip_hash": "%{source_ip_hash}",
  "source_ip_country": "%{source_ip_country}",
  "source_port": %{source_port:0},
  "dest_ip": "%{destination_ip}",
  "dest_port": %{destination_port:5000},
  "attack_type": "%{attack_type}",
  "soap_action": "%{[upnp_soap_action]}",
  "upnp_action": "%{[upnp_action]}",
  "external_port": "%{[upnp_external_port]}",
  "internal_port": "%{[upnp_internal_port]}",
  "internal_client": "%{[upnp_internal_client]}",
  "protocol": "%{[upnp_protocol]}",
  "attack_details": %{[attack_details]:{}}
}'
        user => "${CLICKHOUSE_USER:honeynet}"
        password => "${CLICKHOUSE_PASSWORD:changeme}"
      }
    }

    # Debug output (optional, comment out in production)
    # stdout {
    #   codec => rubydebug
    # }
  }
}
