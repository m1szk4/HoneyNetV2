# Suricata IDS Logstash Pipeline
# Processes Suricata network intrusion detection alerts

input {
  file {
    path => "/input/suricata/eve.json"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/suricata_sincedb"
    codec => json
    type => "suricata"
  }
}

filter {
  if [type] == "suricata" {
    # Only process alert events
    if [event_type] != "alert" {
      drop { }
    }

    # Parse timestamp first
    date {
      match => ["timestamp", "ISO8601"]
      target => "@timestamp"
    }

    # GeoIP lookup BEFORE anonymization
    if [src_ip] {
      geoip {
        source => "src_ip"
        target => "geoip"
        fields => ["country_code2"]
        tag_on_failure => ["_geoip_lookup_failure"]
      }

      # Extract country code
      if [geoip][country_code2] {
        mutate {
          add_field => { "source_ip_country" => "%{[geoip][country_code2]}" }
        }
      } else {
        mutate {
          add_field => { "source_ip_country" => "" }
        }
      }
    }

    # Anonymize source IP AFTER GeoIP
    ruby {
      code => '
        require "digest"
        salt = ENV["ANON_SALT"] || "default_salt"
        if event.get("[src_ip]")
          ip = event.get("[src_ip]")
          hashed_ip = Digest::SHA256.hexdigest(salt + ip.to_s)
          event.set("source_ip_hash", hashed_ip[0..15])
        end
      '
    }

    # Extract alert details
    if [alert] {
      mutate {
        add_field => {
          "alert_signature" => "%{[alert][signature]}"
          "alert_category" => "%{[alert][category]}"
          "alert_severity" => "%{[alert][severity]}"
          "signature_id" => "%{[alert][signature_id]}"
          "revision" => "%{[alert][rev]}"
        }
      }

      # Extract MITRE ATT&CK metadata
      if [alert][metadata] {
        ruby {
          code => '
            metadata = event.get("[alert][metadata]")
            if metadata.is_a?(Array)
              mitre_technique = ""
              mitre_tactic = ""
              metadata.each do |item|
                if item.is_a?(Hash)
                  if item.key?("mitre_technique_id")
                    mitre_technique = item["mitre_technique_id"]
                  elsif item.key?("mitre_tactic_id")
                    mitre_tactic = item["mitre_tactic_id"]
                  end
                end
              end
              event.set("mitre_technique_id", mitre_technique) unless mitre_technique.empty?
              event.set("mitre_tactic", mitre_tactic) unless mitre_tactic.empty?
            end
          '
          tag_on_exception => "_ruby_mitre_parsing_error"
        }
      }
    }

    # Extract payload (if available)
    if [payload_printable] {
      mutate {
        add_field => { "payload" => "%{payload_printable}" }
      }
    }

    # Protocol normalization
    if [proto] {
      mutate {
        add_field => { "protocol" => "%{proto}" }
      }
    }

    # Remove original source IP and temporary fields
    mutate {
      remove_field => ["src_ip", "geoip"]
    }
  }
}

output {
  # IDS alerts table
  http {
    url => "http://${CLICKHOUSE_HOST}:${CLICKHOUSE_PORT}/?query=INSERT%20INTO%20${CLICKHOUSE_DB}.ids_alerts%20FORMAT%20JSONEachRow"
    http_method => "post"
    format => "json_batch"
    content_type => "application/json"
    automatic_retries => 3
    mapping => {
      "timestamp" => "%{@timestamp}"
      "alert_id" => "%{flow_id}"
      "source_ip_hash" => "%{source_ip_hash}"
      "source_ip_country" => "%{source_ip_country}"
      "source_port" => "%{src_port}"
      "dest_ip" => "%{dest_ip}"
      "dest_port" => "%{dest_port}"
      "protocol" => "%{protocol}"
      "alert_signature" => "%{alert_signature}"
      "alert_category" => "%{alert_category}"
      "alert_severity" => "%{alert_severity}"
      "signature_id" => "%{signature_id}"
      "revision" => "%{revision}"
      "payload" => "%{payload}"
      "mitre_technique_id" => "%{mitre_technique_id}"
      "mitre_tactic" => "%{mitre_tactic}"
    }
  }

  # Debug output (optional)
  # stdout { codec => rubydebug }
}
