# Zeek Network Security Monitor Logstash Pipeline
# Processes Zeek connection and protocol logs

input {
  # Zeek connection logs
  file {
    path => "/input/zeek/current/conn.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/zeek_conn_sincedb"
    codec => json
    type => "zeek_conn"
  }

  # Zeek HTTP logs
  file {
    path => "/input/zeek/current/http.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/zeek_http_sincedb"
    codec => json
    type => "zeek_http"
  }

  # Zeek DNS logs
  file {
    path => "/input/zeek/current/dns.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/zeek_dns_sincedb"
    codec => json
    type => "zeek_dns"
  }

  # Zeek SSH logs
  file {
    path => "/input/zeek/current/ssh.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/zeek_ssh_sincedb"
    codec => json
    type => "zeek_ssh"
  }
}

filter {
  # Process Zeek connection logs
  if [type] == "zeek_conn" {
    # Anonymize source IP
    ruby {
      code => '
        require "digest"
        salt = ENV["ANON_SALT"] || "default_salt"
        if event.get("id.orig_h") || event.get("[id][orig_h]")
          ip = event.get("id.orig_h") || event.get("[id][orig_h]")
          hashed_ip = Digest::SHA256.hexdigest(salt + ip.to_s)
          event.set("source_ip_hash", hashed_ip[0..15])
        end
      '
    }

    # Parse timestamp
    date {
      match => ["ts", "UNIX"]
      target => "@timestamp"
    }

    # Normalize field names
    mutate {
      rename => {
        "[id][orig_h]" => "orig_h"
        "[id][orig_p]" => "orig_p"
        "[id][resp_h]" => "resp_h"
        "[id][resp_p]" => "resp_p"
      }
    }

    # Remove original IP
    mutate {
      remove_field => ["orig_h", "id.orig_h"]
    }
  }

  # Process Zeek HTTP logs
  if [type] == "zeek_http" {
    # Anonymize source IP
    ruby {
      code => '
        require "digest"
        salt = ENV["ANON_SALT"] || "default_salt"
        if event.get("id.orig_h") || event.get("[id][orig_h]")
          ip = event.get("id.orig_h") || event.get("[id][orig_h]")
          hashed_ip = Digest::SHA256.hexdigest(salt + ip.to_s)
          event.set("source_ip_hash", hashed_ip[0..15])
        end
      '
    }

    date {
      match => ["ts", "UNIX"]
      target => "@timestamp"
    }

    mutate {
      rename => {
        "[id][orig_h]" => "orig_h"
        "[id][orig_p]" => "orig_p"
        "[id][resp_h]" => "resp_h"
        "[id][resp_p]" => "resp_p"
      }
    }

    mutate {
      remove_field => ["orig_h", "id.orig_h"]
    }
  }
}

output {
  # Network connections table
  if [type] == "zeek_conn" {
    http {
      url => "http://${CLICKHOUSE_HOST}:${CLICKHOUSE_PORT}/?query=INSERT%20INTO%20${CLICKHOUSE_DB}.network_connections%20FORMAT%20JSONEachRow"
      http_method => "post"
      format => "json_batch"
      content_type => "application/json"
      automatic_retries => 3
      mapping => {
        "timestamp" => "%{@timestamp}"
        "uid" => "%{uid}"
        "source_ip_hash" => "%{source_ip_hash}"
        "source_port" => "%{orig_p}"
        "dest_ip" => "%{resp_h}"
        "dest_port" => "%{resp_p}"
        "protocol" => "%{proto}"
        "service" => "%{service}"
        "duration" => "%{duration}"
        "orig_bytes" => "%{orig_bytes}"
        "resp_bytes" => "%{resp_bytes}"
        "conn_state" => "%{conn_state}"
        "local_orig" => "%{local_orig}"
        "local_resp" => "%{local_resp}"
        "missed_bytes" => "%{missed_bytes}"
        "history" => "%{history}"
        "orig_pkts" => "%{orig_pkts}"
        "resp_pkts" => "%{resp_pkts}"
      }
    }
  }

  # HTTP requests table
  if [type] == "zeek_http" {
    http {
      url => "http://${CLICKHOUSE_HOST}:${CLICKHOUSE_PORT}/?query=INSERT%20INTO%20${CLICKHOUSE_DB}.http_requests%20FORMAT%20JSONEachRow"
      http_method => "post"
      format => "json_batch"
      content_type => "application/json"
      automatic_retries => 3
      mapping => {
        "timestamp" => "%{@timestamp}"
        "source_ip_hash" => "%{source_ip_hash}"
        "source_port" => "%{orig_p}"
        "dest_ip" => "%{resp_h}"
        "dest_port" => "%{resp_p}"
        "method" => "%{method}"
        "host" => "%{host}"
        "uri" => "%{uri}"
        "user_agent" => "%{user_agent}"
        "referrer" => "%{referrer}"
        "status_code" => "%{status_code}"
        "response_body_len" => "%{response_body_len}"
        "request_body" => ""
      }
    }
  }

  # Debug output (optional)
  # stdout { codec => rubydebug }
}
