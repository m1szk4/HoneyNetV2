# Logstash Pipeline for Conpot ICS/SCADA Honeypot
# Processes Conpot JSON logs and sends to ClickHouse

input {
  file {
    path => "/input/conpot/conpot.json"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/sincedb/conpot"
    codec => json
    type => "conpot"
  }
}

filter {
  # Parse timestamp
  date {
    match => ["timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss"]
    target => "@timestamp"
  }

  # Anonymize source IP
  if [remote] or [src_ip] {
    # Use remote if src_ip not available
    if ![src_ip] and [remote] {
      # Extract IP from remote (format can be "IP:port")
      ruby {
        code => '
          remote = event.get("remote")
          if remote
            ip = remote.to_s.split(":").first
            event.set("src_ip", ip)
          end
        '
      }
    }

    # GeoIP lookup
    geoip {
      source => "src_ip"
      target => "geoip"
      fields => ["country_code2", "country_name"]
    }

    if [geoip][country_code2] {
      mutate {
        add_field => { "country_code" => "%{[geoip][country_code2]}" }
      }
    } else {
      mutate {
        add_field => { "country_code" => "XX" }
      }
    }

    # Anonymize
    ruby {
      code => '
        require "openssl"
        salt = ENV["SALT_SECRET"] || "default-salt-change-me"
        src_ip = event.get("src_ip")
        if src_ip
          hmac = OpenSSL::HMAC.hexdigest("SHA256", salt, src_ip)
          event.set("source_ip_anon", hmac)
        end
      '
    }
  }

  # Classify by data type
  if [data_type] == "modbus" or [request] =~ /modbus/i {
    mutate {
      add_field => {
        "event_type" => "conpot_modbus"
        "protocol" => "modbus"
      }
    }

    # Classify Modbus operations
    if [request] =~ /(write|set)/i {
      mutate {
        add_field => {
          "attack_technique" => "T0836"
          "attack_tactic" => "ICS Impair Process Control"
          "severity" => "high"
        }
      }
    } else if [request] =~ /(read|get)/i {
      mutate {
        add_field => {
          "attack_technique" => "T0802"
          "attack_tactic" => "ICS Collection"
          "severity" => "medium"
        }
      }
    } else {
      mutate {
        add_field => { "severity" => "low" }
      }
    }

  } else if [data_type] == "bacnet" {
    mutate {
      add_field => {
        "event_type" => "conpot_bacnet"
        "protocol" => "bacnet"
        "attack_technique" => "T0846"
        "attack_tactic" => "ICS Collection"
        "severity" => "medium"
      }
    }

  } else if [data_type] == "s7comm" {
    mutate {
      add_field => {
        "event_type" => "conpot_s7comm"
        "protocol" => "s7comm"
        "attack_technique" => "T0836"
        "attack_tactic" => "ICS Impair Process Control"
        "severity" => "medium"
      }
    }

  } else if [data_type] == "http" or [request] =~ /^(GET|POST|HEAD)/i {
    mutate {
      add_field => {
        "event_type" => "conpot_http"
        "protocol" => "http"
        "attack_technique" => "T1190"
        "attack_tactic" => "Initial Access"
        "severity" => "medium"
      }
    }

  } else {
    # Generic ICS connection
    mutate {
      add_field => {
        "event_type" => "conpot_connection"
        "attack_technique" => "T0846"
        "attack_tactic" => "ICS Collection"
        "severity" => "info"
      }
    }
  }

  # Extract port information
  if [remote] {
    ruby {
      code => '
        remote = event.get("remote")
        if remote && remote.to_s.include?(":")
          parts = remote.to_s.split(":")
          if parts.length >= 2
            event.set("source_port", parts[1].to_i)
          end
        end
      '
    }
  }

  # Store request details in payload
  if [request] {
    mutate {
      copy => { "request" => "payload" }
    }
  }

  # Add metadata for ICS operations
  if [function_code] or [slave_id] or [unit_id] {
    ruby {
      code => '
        metadata = {}
        metadata["function_code"] = event.get("function_code") if event.get("function_code")
        metadata["slave_id"] = event.get("slave_id") if event.get("slave_id")
        metadata["unit_id"] = event.get("unit_id") if event.get("unit_id")
        if metadata.any?
          require "json"
          event.set("metadata", metadata.to_json)
        end
      '
    }
  }

  # Normalize field names
  mutate {
    rename => {
      "public_ip" => "dest_ip"
      "remote_port" => "source_port"
    }
  }

  # Add honeypot name
  mutate {
    add_field => {
      "honeypot_name" => "conpot"
      "is_malicious" => "1"
    }
  }

  # Set default dest_port if not present (based on protocol)
  if ![dest_port] {
    if [protocol] == "modbus" {
      mutate { add_field => { "dest_port" => "502" } }
    } else if [protocol] == "bacnet" {
      mutate { add_field => { "dest_port" => "47808" } }
    } else if [protocol] == "s7comm" {
      mutate { add_field => { "dest_port" => "102" } }
    }
  }

  # Convert types
  if [source_port] {
    mutate { convert => { "source_port" => "integer" } }
  }
  if [dest_port] {
    mutate { convert => { "dest_port" => "integer" } }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => [
      "src_ip", "remote", "geoip", "path", "host", "message",
      "tags", "@version", "data_type", "function_code", "slave_id", "unit_id"
    ]
  }
}

output {
  # Send to ClickHouse events table (all ICS events go to main table)
  http {
    url => "http://clickhouse:8123/?query=INSERT%20INTO%20honeynet.events%20FORMAT%20JSONEachRow"
    http_method => "post"
    format => "json_batch"
    content_type => "application/json"
    automatic_retries => 3
    retry_non_idempotent => true
    pool_max => 50
    pool_max_per_route => 25
  }

  # Debug output (comment out in production)
  # stdout { codec => rubydebug }
}
