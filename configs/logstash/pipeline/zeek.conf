# Logstash Pipeline for Zeek Network Analysis
# Processes Zeek conn.log (TSV format) and sends to ClickHouse

input {
  file {
    path => "/input/zeek/conn.log*"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/sincedb/zeek_conn"
    codec => plain
    type => "zeek_conn"
    exclude => "*.gz"
  }
}

filter {
  # Drop comment lines and empty lines
  if [message] =~ /^#/ or [message] == "" {
    drop { }
  }

  # Parse TSV format (Zeek conn.log columns)
  csv {
    separator => "	"  # Tab separator
    columns => [
      "ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p",
      "proto", "service", "duration", "orig_bytes", "resp_bytes",
      "conn_state", "local_orig", "local_resp", "missed_bytes", "history",
      "orig_pkts", "orig_ip_bytes", "resp_pkts", "resp_ip_bytes"
    ]
    skip_empty_columns => true
  }

  # Parse timestamp (Unix epoch)
  date {
    match => ["ts", "UNIX"]
    target => "@timestamp"
  }

  # Anonymize source IP
  if [id.orig_h] {
    # GeoIP lookup before anonymization
    geoip {
      source => "id.orig_h"
      target => "geoip"
      fields => ["country_code2", "country_name"]
    }

    # Extract country code
    if [geoip][country_code2] {
      mutate {
        add_field => { "country_code" => "%{[geoip][country_code2]}" }
      }
    } else {
      mutate {
        add_field => { "country_code" => "XX" }
      }
    }

    # Anonymize IP
    ruby {
      code => '
        require "openssl"
        salt = ENV["SALT_SECRET"] || "default-salt-change-me"
        src_ip = event.get("id.orig_h")
        if src_ip
          hmac = OpenSSL::HMAC.hexdigest("SHA256", salt, src_ip)
          event.set("source_ip_anon", hmac)
        end
      '
    }
  }

  # Normalize field names
  mutate {
    rename => {
      "id.orig_p" => "source_port"
      "id.resp_h" => "dest_ip"
      "id.resp_p" => "dest_port"
      "uid" => "session_id"
      "proto" => "protocol"
    }
  }

  # Calculate total payload size
  if [orig_bytes] and [resp_bytes] {
    ruby {
      code => '
        orig = event.get("orig_bytes")
        resp = event.get("resp_bytes")
        # Handle "-" values (Zeek uses "-" for unset fields)
        orig_val = (orig.nil? || orig == "-") ? 0 : orig.to_i
        resp_val = (resp.nil? || resp == "-") ? 0 : resp.to_i
        event.set("payload_size", orig_val + resp_val)
      '
    }
  }

  # Add fixed fields
  mutate {
    add_field => {
      "event_type" => "zeek_conn"
      "honeypot_name" => "zeek"
      "is_malicious" => "1"
    }
  }

  # Convert numeric fields (handle "-" as null)
  ruby {
    code => '
      ["source_port", "dest_port", "orig_bytes", "resp_bytes",
       "orig_pkts", "resp_pkts", "orig_ip_bytes", "resp_ip_bytes"].each do |field|
        val = event.get(field)
        if val && val != "-"
          event.set(field, val.to_i)
        else
          event.remove(field)
        end
      end

      # Duration as float
      duration = event.get("duration")
      if duration && duration != "-"
        event.set("duration", duration.to_f)
      else
        event.remove("duration")
      end
    '
  }

  # Store connection state in metadata
  if [conn_state] {
    mutate {
      add_field => { "metadata" => "{\"conn_state\": \"%{conn_state}\", \"history\": \"%{history}\"}" }
    }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => [
      "id.orig_h", "geoip", "path", "host", "message", "tags", "@version",
      "ts", "local_orig", "local_resp", "missed_bytes", "history", "conn_state"
    ]
  }
}

output {
  # Send to ClickHouse events table
  http {
    url => "http://clickhouse:8123/?query=INSERT%20INTO%20honeynet.events%20FORMAT%20JSONEachRow"
    http_method => "post"
    format => "json_batch"
    content_type => "application/json"
    automatic_retries => 3
    retry_non_idempotent => true
    pool_max => 50
    pool_max_per_route => 25
  }

  # Debug output (comment out in production)
  # stdout { codec => rubydebug }
}
