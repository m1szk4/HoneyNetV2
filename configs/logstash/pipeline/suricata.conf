# Logstash Pipeline for Suricata IDS Alerts
# Processes EVE JSON logs from Suricata and sends to ClickHouse

input {
  file {
    path => "/input/suricata/eve.json"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/sincedb/suricata"
    codec => json
    type => "suricata"
  }
}

filter {
  # Only process alert events
  if [event_type] != "alert" {
    drop { }
  }

  # Parse timestamp
  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
  }

  # Extract source IP for anonymization
  if [src_ip] {
    # Anonymize source IP using HMAC-SHA256
    ruby {
      code => '
        require "openssl"
        salt = ENV["SALT_SECRET"] || "default-salt-change-me"
        src_ip = event.get("src_ip")
        if src_ip
          hmac = OpenSSL::HMAC.hexdigest("SHA256", salt, src_ip)
          event.set("source_ip_anon", hmac)
        end
      '
    }

    # GeoIP lookup on original IP before anonymization
    geoip {
      source => "src_ip"
      target => "geoip"
      fields => ["country_code2", "country_name", "continent_code", "latitude", "longitude"]
    }

    # Extract country code to top level
    if [geoip][country_code2] {
      mutate {
        add_field => { "country_code" => "%{[geoip][country_code2]}" }
      }
    } else {
      mutate {
        add_field => { "country_code" => "XX" }
      }
    }

    # Extract ASN if available
    if [geoip][as_org] {
      mutate {
        add_field => { "asn" => "%{[geoip][as_org]}" }
      }
    }
  }

  # Extract MITRE ATT&CK technique from metadata
  if [alert][metadata] {
    ruby {
      code => '
        metadata = event.get("[alert][metadata]")
        if metadata
          # Metadata can be array or hash
          if metadata.is_a?(Array)
            metadata.each do |item|
              if item.to_s.include?("mitre_technique_id")
                technique = item.split(" ").last
                event.set("mitre_technique", technique)
              elsif item.to_s.include?("mitre_tactic_id")
                tactic = item.split(" ").last
                event.set("mitre_tactic_id", tactic)
              end
            end
          elsif metadata.is_a?(Hash)
            event.set("mitre_technique", metadata["mitre_technique_id"]) if metadata["mitre_technique_id"]
            event.set("mitre_tactic_id", metadata["mitre_tactic_id"]) if metadata["mitre_tactic_id"]
          end
        end
      '
    }
  }

  # Map MITRE technique to tactic name
  if [mitre_technique] {
    if [mitre_technique] =~ /^T1595/ {
      mutate { add_field => { "mitre_tactic" => "Reconnaissance" } }
    } else if [mitre_technique] =~ /^T1078|^T1190/ {
      mutate { add_field => { "mitre_tactic" => "Initial Access" } }
    } else if [mitre_technique] =~ /^T1059/ {
      mutate { add_field => { "mitre_tactic" => "Execution" } }
    } else if [mitre_technique] =~ /^T1053/ {
      mutate { add_field => { "mitre_tactic" => "Persistence" } }
    } else if [mitre_technique] =~ /^T1056|^T1110|^T1557/ {
      mutate { add_field => { "mitre_tactic" => "Credential Access" } }
    } else if [mitre_technique] =~ /^T1046|^T1082|^T1083/ {
      mutate { add_field => { "mitre_tactic" => "Discovery" } }
    } else if [mitre_technique] =~ /^T1021|^T1210/ {
      mutate { add_field => { "mitre_tactic" => "Lateral Movement" } }
    } else if [mitre_technique] =~ /^T1074/ {
      mutate { add_field => { "mitre_tactic" => "Collection" } }
    } else if [mitre_technique] =~ /^T1071|^T1105/ {
      mutate { add_field => { "mitre_tactic" => "Command and Control" } }
    } else if [mitre_technique] =~ /^T1498/ {
      mutate { add_field => { "mitre_tactic" => "Impact" } }
    } else if [mitre_technique] =~ /^T1584/ {
      mutate { add_field => { "mitre_tactic" => "Resource Development" } }
    } else if [mitre_technique] =~ /^T0802|^T0846/ {
      mutate { add_field => { "mitre_tactic" => "ICS Collection" } }
    } else if [mitre_technique] =~ /^T0836/ {
      mutate { add_field => { "mitre_tactic" => "ICS Impair Process Control" } }
    } else if [mitre_technique] =~ /^T0831/ {
      mutate { add_field => { "mitre_tactic" => "ICS Inhibit Response Function" } }
    } else if [mitre_technique] =~ /^T0815/ {
      mutate { add_field => { "mitre_tactic" => "ICS Impact" } }
    } else if [mitre_technique] =~ /^T0855/ {
      mutate { add_field => { "mitre_tactic" => "ICS Lateral Movement" } }
    } else {
      mutate { add_field => { "mitre_tactic" => "Unknown" } }
    }
  }

  # Map Suricata severity (1=high, 2=medium, 3=low) to text
  if [alert][severity] {
    if [alert][severity] == 1 {
      mutate { add_field => { "severity" => "critical" } }
    } else if [alert][severity] == 2 {
      mutate { add_field => { "severity" => "high" } }
    } else if [alert][severity] == 3 {
      mutate { add_field => { "severity" => "medium" } }
    } else {
      mutate { add_field => { "severity" => "low" } }
    }
  }

  # Normalize field names
  mutate {
    rename => {
      "[alert][signature]" => "alert_signature"
      "[alert][category]" => "alert_category"
      "[alert][signature_id]" => "signature_id"
      "[alert][rev]" => "revision"
      "src_port" => "source_port"
      "dest_ip" => "dest_ip"
      "dest_port" => "dest_port"
      "proto" => "protocol"
    }
  }

  # Extract payload if available
  if [payload_printable] {
    mutate {
      rename => { "payload_printable" => "payload" }
    }
  }

  # Convert types
  mutate {
    convert => {
      "source_port" => "integer"
      "dest_port" => "integer"
      "signature_id" => "integer"
      "revision" => "integer"
    }
  }

  # Add fixed fields
  mutate {
    add_field => {
      "honeypot_name" => "suricata"
      "is_malicious" => "1"
    }
  }

  # Remove original src_ip for privacy (we have anonymized version)
  mutate {
    remove_field => ["src_ip", "geoip", "path", "host", "message", "event_type", "tags"]
  }
}

output {
  # Send to ClickHouse
  http {
    url => "http://clickhouse:8123/?query=INSERT%20INTO%20honeynet.ids_alerts%20FORMAT%20JSONEachRow"
    http_method => "post"
    format => "json_batch"
    content_type => "application/json"
    automatic_retries => 3
    retry_non_idempotent => true
    pool_max => 50
    pool_max_per_route => 25
    # Add authentication if ClickHouse requires it
    # headers => {
    #   "X-ClickHouse-User" => "${CLICKHOUSE_USER:default}"
    #   "X-ClickHouse-Key" => "${CLICKHOUSE_PASSWORD:}"
    # }
  }

  # Debug output (comment out in production)
  # stdout { codec => rubydebug }
}
