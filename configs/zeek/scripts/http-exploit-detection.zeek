##! Zeek script to detect HTTP-based exploitation attempts
##! Identifies common web exploits targeting IoT devices
##!
##! Author: HoneyNetV2 Project
##! MITRE ATT&CK: T1190 (Exploit Public-Facing Application)

@load base/frameworks/notice
@load base/protocols/http

module HTTPExploit;

export {
    redef enum Notice::Type += {
        ## Shellshock exploit attempt detected
        HTTP_Shellshock_Attempt,
        ## Path traversal attack detected
        HTTP_Path_Traversal,
        ## SQL injection attempt detected
        HTTP_SQLi_Attempt,
        ## Command injection detected
        HTTP_Command_Injection,
        ## CGI exploit attempt
        HTTP_CGI_Exploit,
        ## Suspicious user agent (potential exploit tool)
        HTTP_Suspicious_UserAgent,
    };

    ## Shellshock patterns
    const shellshock_patterns = /\(\)\s*\{.*:;/ &redef;

    ## Path traversal patterns
    const path_traversal_patterns = /(\.\.[\/\\]|\.\.%2[fF]|\.\.%5[cC])/ &redef;

    ## SQL injection patterns
    const sqli_patterns = /(union.*select|select.*from|insert.*into|update.*set|delete.*from|drop.*table|exec.*\(|xp_.*cmdshell)/i &redef;

    ## Command injection patterns
    const command_injection_patterns = /(\||;|`|\$\(|<\(|>\(|&lt;&lt;|%0[aA]|%0[dD])/ &redef;

    ## Known malicious user agents
    const malicious_user_agents = /^(Mirai|Gafgyt|python-requests|curl|wget|Nikto|sqlmap|nmap|masscan|ZmEu|DirBuster)/i &redef;

    ## Common exploit tool fingerprints
    const exploit_tool_patterns = /^(metasploit|nmap|masscan|nikto|sqlmap|w3af|havij|acunetix)/i &redef;
}

## Check HTTP headers for Shellshock
event http_header(c: connection, is_orig: bool, name: string, value: string)
{
    if (!is_orig)
        return;

    # Check for Shellshock in any header
    if (shellshock_patterns in value)
    {
        NOTICE([$note=HTTP_Shellshock_Attempt,
                $conn=c,
                $msg=fmt("Shellshock exploit attempt in HTTP header '%s' from %s",
                        name, c$id$orig_h),
                $sub=fmt("Header value: %s", value),
                $identifier=cat(c$id$orig_h, c$uid)]);
    }

    # Check User-Agent specifically
    if (name == "USER-AGENT")
    {
        # Shellshock via User-Agent
        if (shellshock_patterns in value)
        {
            NOTICE([$note=HTTP_Shellshock_Attempt,
                    $conn=c,
                    $msg=fmt("Shellshock in User-Agent from %s", c$id$orig_h),
                    $sub=value,
                    $identifier=cat(c$id$orig_h, c$uid)]);
        }

        # Known malicious user agents
        if (malicious_user_agents in value)
        {
            NOTICE([$note=HTTP_Suspicious_UserAgent,
                    $conn=c,
                    $msg=fmt("Malicious/exploit tool user agent from %s", c$id$orig_h),
                    $sub=value,
                    $identifier=cat(c$id$orig_h, c$uid)]);
        }
    }
}

## Check HTTP requests for exploits
event http_request(c: connection, method: string, original_URI: string,
                   unescaped_URI: string, version: string)
{
    local src = c$id$orig_h;

    # Check for path traversal
    if (path_traversal_patterns in unescaped_URI)
    {
        NOTICE([$note=HTTP_Path_Traversal,
                $conn=c,
                $msg=fmt("Path traversal attempt from %s", src),
                $sub=fmt("URI: %s", unescaped_URI),
                $identifier=cat(src, c$uid)]);
    }

    # Check for SQL injection in URI
    if (sqli_patterns in unescaped_URI)
    {
        NOTICE([$note=HTTP_SQLi_Attempt,
                $conn=c,
                $msg=fmt("SQL injection attempt from %s", src),
                $sub=fmt("URI: %s", unescaped_URI),
                $identifier=cat(src, c$uid)]);
    }

    # Check for command injection
    if (command_injection_patterns in unescaped_URI)
    {
        NOTICE([$note=HTTP_Command_Injection,
                $conn=c,
                $msg=fmt("Command injection attempt from %s", src),
                $sub=fmt("URI: %s", unescaped_URI),
                $identifier=cat(src, c$uid)]);
    }

    # Check for CGI-bin exploits
    if (/cgi-bin/ in unescaped_URI && (/\?.*=.*[;|&`$]/ in unescaped_URI || shellshock_patterns in unescaped_URI))
    {
        NOTICE([$note=HTTP_CGI_Exploit,
                $conn=c,
                $msg=fmt("CGI exploit attempt from %s", src),
                $sub=fmt("URI: %s", unescaped_URI),
                $identifier=cat(src, c$uid)]);
    }
}

## Check POST data for exploits
event http_entity_data(c: connection, is_orig: bool, length: count, data: string)
{
    if (!is_orig)
        return;

    local src = c$id$orig_h;

    # Check POST body for SQL injection
    if (sqli_patterns in data)
    {
        NOTICE([$note=HTTP_SQLi_Attempt,
                $conn=c,
                $msg=fmt("SQL injection in POST data from %s", src),
                $sub=fmt("Data sample: %s", data[0:200]),
                $identifier=cat(src, c$uid, "-post")]);
    }

    # Check for command injection in POST data
    if (command_injection_patterns in data)
    {
        NOTICE([$note=HTTP_Command_Injection,
                $conn=c,
                $msg=fmt("Command injection in POST data from %s", src),
                $sub=fmt("Data sample: %s", data[0:200]),
                $identifier=cat(src, c$uid, "-post")]);
    }

    # Check for Shellshock in POST data
    if (shellshock_patterns in data)
    {
        NOTICE([$note=HTTP_Shellshock_Attempt,
                $conn=c,
                $msg=fmt("Shellshock in POST data from %s", src),
                $sub=fmt("Data sample: %s", data[0:200]),
                $identifier=cat(src, c$uid, "-post")]);
    }
}

## Create custom log for HTTP exploits
event zeek_init()
{
    Log::create_stream(HTTPExploit::LOG,
                      [$columns=record {
                          ts: time &log;
                          uid: string &log;
                          src_ip: addr &log;
                          src_port: port &log;
                          dst_ip: addr &log;
                          dst_port: port &log;
                          method: string &log &optional;
                          uri: string &log &optional;
                          user_agent: string &log &optional;
                          exploit_type: string &log;
                          note: string &log &optional;
                      },
                      $path="http_exploits"]);
}

## Log HTTP exploit attempts
hook Notice::policy(n: Notice::Info)
{
    if (n$note in set(HTTP_Shellshock_Attempt, HTTP_Path_Traversal,
                     HTTP_SQLi_Attempt, HTTP_Command_Injection,
                     HTTP_CGI_Exploit, HTTP_Suspicious_UserAgent))
    {
        if (n?$conn)
        {
            local c = n$conn;
            local exploit_type = "";

            switch (n$note) {
                case HTTP_Shellshock_Attempt:
                    exploit_type = "shellshock";
                    break;
                case HTTP_Path_Traversal:
                    exploit_type = "path_traversal";
                    break;
                case HTTP_SQLi_Attempt:
                    exploit_type = "sql_injection";
                    break;
                case HTTP_Command_Injection:
                    exploit_type = "command_injection";
                    break;
                case HTTP_CGI_Exploit:
                    exploit_type = "cgi_exploit";
                    break;
                case HTTP_Suspicious_UserAgent:
                    exploit_type = "suspicious_ua";
                    break;
            }

            Log::write(HTTPExploit::LOG, [
                $ts=network_time(),
                $uid=c$uid,
                $src_ip=c$id$orig_h,
                $src_port=c$id$orig_p,
                $dst_ip=c$id$resp_h,
                $dst_port=c$id$resp_p,
                $exploit_type=exploit_type,
                $note=n$msg
            ]);
        }
    }
}
